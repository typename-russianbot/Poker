#include "../../includes/poker/Deck.h"

//& Resources
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: Deck(void)
//* @def: Constructor

Deck::Deck(void)
{
    //* A.L.G.O.R.I.T.H.M.
    //* 1. randomly seed a card (i.e: generate a random suit & rank)
    //* 2. compare the randomly seeded card with all elements currently stored
    //* 3a. if not stored, store it
    //* 3b. if stored, re-seed & repeat

    return;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: ~Deck(void)
//* @def: Destructor

Deck::~Deck(void)
{
    return;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//& Functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: shuffle(void)
//* @def: Shuffles deck

bool Deck::shuffle(void)
{
    //* A.L.G.O.R.I.T.H.M.
    //* 1. randomly seed a card (i.e: generate a random suit & rank)
    //* 2. compare the randomly seeded card with all elements currently stored
    //* 3a. if not stored, store it
    //* 3b. if stored, re-seed & repeat

    //* note: we cannot traverse the stack itself, use an array to create the pattern of cards that will be push onto the stack

    int insertions = 0;

    if (mStack.size() != 0)
    {
        //! want to keep track of the number of successful insertions we've had
        while (insertions != 52)
        {
            //* do random seeding here for a card, want to randomly seed a suit/rank

            //* compare seeded value to all other elements in mStack
            for (int i = 0; i <= insertions; i++)
            {
                //* we have 0 elements to start, want to just insert the first rando generated
                //* when we have n elements, we want to compare the rando to each element
                //*
                //! a. hit, re-seed
                //* b. miss, iterate insertions,
            }
        }
    }

    return false;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: reshuffle(void)
//* @def: Wipe the current deck & call shuffle

bool Deck::reshuffle(void)
{
    if (mStack.size() != 0)
    {
        for (size_t i = 0; i < mStack.size() - 1; i++)
        {
            mStack.pop();
        }

        return shuffle();
    }

    return false;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: draw(void)
//* @def: Stores, then removes the card on the top of the stack

Cards Deck::draw(void)
{
    Cards top = mStack.top();
    mStack.pop();

    return top;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public:
//* @def:
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//& Overloads
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: operator<<(ostream&, Cards)
//* @def: Overloaded '<<'

ostream &operator<<(ostream &out, Cards cards)
{
    out << cards.mRank << " of " << cards.mSuit;
    return out;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: operator=
//* @def: Overloaded '='

Cards &Cards::operator=(Cards &other)
{
    this->mRank = other.mRank;
    this->mSuit = other.mSuit;

    return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public:
//* @def:

bool Cards::operator==(Cards &other) const
{
    if (this->mRank == other.mRank && this->mSuit == other.mRank)
        return true;

    return false;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
